// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;



/** Imports */
// first run "forge install smartcontractkit/chainlink-brownie-contracts@0.8.0 --no-commit"
// remap the chainlink VRF interface in foundry.toml: remapping = ['@chainlink/contracts/=lib/chainlink-brownie-contracts/contracts']
import {VRFCoordinatorV2Interface} from "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import {VRFConsumerBaseV2} from "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";
                                

/**
 * @title Raffle Lottery smart contract
 * @author Emmanuel Acho (Courtesy of @Patrick Collins - Cyfrin: https://updraft.cyfrin.io/)
 * @notice This contract is for creating a raffle lottery
 * @dev This contract implements chainlink VRF V2 for random number generation
 * @dev This contract also implements chainlink automation for lottery draw
 * @dev Checks, Effects, Interactions (CEI) pattern is used to prevent reentrancy attacks
 * @dev the contract has four functions: enterRaffle, checkUpkeep, performUpkeep and fulfillRandomWords
 * enterRaffle(): allows participants to enter the raffle by sending ether
 * checkUpkeep(): checks if the raffle needs to be picked. It serves as a periodic trigger for the performUpkeep function
 * performUpkeep(): picks a winner for the raffle. It initiates the winner selection process
 * fulfillRandomWords(): completes the process of picking a winner and resets the raffle for the next draw
 * The execution of performUpkeep and fulfillRandomWords depends on external calls from Chainlink services:
 * 1. Keepers for checkUpkeep and performUpkeep
 * 2. Chainlink VRF for fulfillRandomWords
 */

contract Raffle is VRFConsumerBaseV2 {

        /** Errors */
    error Raffle__NotEnoughEthSent();
    error Raffle__TransferFailed();
    error Raffle__RaffleNotOpen();
    error Raffle__UpkeepNotNeeded(uint256 currentBalance, uint256 numParticipants, uint256 raffleState); // or RaffleState raffleState);
    //error Raffle__NotEnoughTimePassed();

    /** Type Declarations */
    enum RaffleState {OPEN, CALCUATING, CLOSED}

    /** State Variables */
    uint16 private constant REQUEST_CONFIRMATIONS = 3; // @dev is the number of confirmations for the chainlink VRF
    uint32 private constant NUM_WORDS = 1; // @dev is the number of random words to be generated by the chainlink VRF
    address payable[] private s_participants; // @dev is the list of all participants in the raffle
    uint256 private s_lastTimeStamp; // @dev is the last time a winner was picked ?
    address private s_recentWinner; // @dev is the address of the winner of the raffle
    RaffleState private s_raffleState; // @dev is the state of the raffle 

    // Immutable variables
    uint256 private immutable i_ticketPrice; // (i_entranceFee) is the price of a ticket
    uint256 private immutable i_interval; // @dev is the time interval for the raffle draw in seconds
    VRFCoordinatorV2Interface private immutable i_vrfCoordinator; // @dev is the address of the chainlink VRF coordinator
    bytes32 private immutable i_gasLane; // [keyHash] @dev is the gas lane for the chainlink VRF
    uint64 private immutable i_subscriptionId; // @dev is the subscription id for the chainlink VRF
    uint32 private immutable i_callbackGasLimit; // @dev is the gas limit for the chainlink VRF
   
    /** Events */
    // This event is emitted when a participant enters the raffle
    event EnteredRaffle(address indexed _participant); // indexed means that the event can be filtered by the participant's address
    // This event is emitted when a winner is picked
    event PickedWinner(address indexed winner);
    event RequestedRaffleWinner(uint256 indexed requestId);


    // The constructor of the Raffle contract calls the constructor of the VRFConsumerBaseV2 contract passing the address of the chainlink VRF coordinator
    // This sets up the link between the Raffle contract and the chainlink VRF coordinator
    constructor(uint256 _ticketPrice, 
        uint256 interval, 
        address vrfCoordinator, 
        bytes32 gasLane, 
        uint64 subscriptionID, 
        uint32 callbackGasLimit
     ) VRFConsumerBaseV2(vrfCoordinator){
        i_ticketPrice = _ticketPrice;
        i_interval = interval;
        s_lastTimeStamp = block.timestamp;
        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinator);
        i_gasLane = gasLane;
        i_subscriptionId = subscriptionID;
        i_callbackGasLimit = callbackGasLimit;
        s_raffleState = RaffleState.OPEN;


    }

    function enterRaffle() external payable {
       // Check if the participant has sent enough ether to enter the raffle
       // require(msg.value >= i_ticketPrice, "Raffle: Didn't send enough ether to enter the raffle.");
        if (msg.value < i_ticketPrice) {
            revert Raffle__NotEnoughEthSent();
        }
        // Check if the raffle is open
        if (s_raffleState != RaffleState.OPEN) {
            revert Raffle__RaffleNotOpen();
        }
        // Add the participant to the list of participants
        s_participants.push(payable(msg.sender));
        // emit an event to notify that a participant has entered the raffle
        emit EnteredRaffle(msg.sender);
       
    }

    /**
     * @dev This function (below) 
     * is called by chainlink automation to check if the raffle needs to be picked.
     * The following must be true for the function to return true:
     * 1. Enough time must have passed since the last winner was picked
     * 1. The raffle state must be open
     * 3. The raffle must have at least one participant (aka has ether in the contract)
     * 4. The subscription is funded with LINK
     */

    function checkUpkeep(bytes memory /* checkData */) public view returns (bool upkeepNeeded, bytes memory /* performData */) {
        bool timeHasPassed = block.timestamp - s_lastTimeStamp >= i_interval;
        bool raffleIsOpen = s_raffleState == RaffleState.OPEN;
        bool hasParticipants = s_participants.length > 0;
        bool hasBalalance = address(this).balance > 0;
        upkeepNeeded = timeHasPassed && raffleIsOpen && hasParticipants && hasBalalance;
        return (upkeepNeeded, "0x0");

    }

    // The following function was previously called pickWinner() but renamed to performUpkeep() to match the checkUpkeep function
    // Now, the performUpkeep function is called by chainlink automation to pick a winner

      function performUpkeep(bytes calldata /* performData */) external {
        // 1. Checks if upkeep is needed
        // 2. Checks if enough time has passed to pick a winner: require(block.timestamp - s_lastTimeStamp >= i_interval, "Raffle: Not enough time has passed to pick a winner.");
        // 2. Gets a random number from chainlink VRF
        // 3. Uses the random number to pick a player from the list of participants
        // 4. Chainlink automation is used to pick a winner, i.e., calling the chainlink VRF to get a random number

            (bool upkeepNeeded, ) = checkUpkeep("");
            if (!upkeepNeeded) {
                revert Raffle__UpkeepNotNeeded(
                    address(this).balance,
                    s_participants.length,
                    uint256(s_raffleState)
                );
            }
        
       // The following line is part of the previous implementation of the function pickWinner()
       /** if (block.timestamp - s_lastTimeStamp < i_interval) {
            // revert Raffle__NotEnoughTimePassed();
            revert();
        } */

        // Set the raffle state to calculating if enough time has passed
        s_raffleState = RaffleState.CALCUATING;

        // 1. Get a random number from chainlink VRF

            uint256 requestId = i_vrfCoordinator.requestRandomWords(
            i_gasLane,// gas lane
            i_subscriptionId, 
            REQUEST_CONFIRMATIONS,
            i_callbackGasLimit,
            NUM_WORDS
        );
        emit RequestedRaffleWinner(requestId);
    }

    function fulfillRandomWords(
        uint256, /**requestId,*/ 
        uint256[] memory randomWord) 
        internal override {
            // Create an index from the random number returned by chainlink VRF
            uint256 indexOfWinner = randomWord[0] % s_participants.length; // Divides the random number by the number of participants and gets the remainder
            // Use the index to pick a winner from the list of participants
            address payable winner = s_participants[indexOfWinner];
            s_recentWinner = winner;
            // Update Raffle state to open 
            s_raffleState = RaffleState.OPEN;
            // Reset the s_participants array
            s_participants = new address payable[](0); // address payable[] private s_participants;
            // Update the s_lastTimeStamp to restart the lottery
            s_lastTimeStamp = block.timestamp;
            // Emit an event to notify that a winner has been picked
            emit PickedWinner(winner); 
            // Send the prize to the winner: Actions above assume the transfer will be successful
            (bool success,) = winner.call{value: address(this).balance}("");
            if (!success) {
                revert Raffle__TransferFailed(); // Revert if the transfer fails
            }
            
            // The above layout follows the CEI pattern described by Patrick Collins. It prevents reentrancy attacks.
            // However,I prefer to note the scenario below because it waits for the transfer to be successful before updating the state of the contract
            /**
            // Update Raffle state to open if the transfer is successful
            s_raffleState = RaffleState.OPEN;
            // Reset the s_participants array
            s_participants = new address payable[](0);
            // Update the s_lastTimeStamp to restart the lottery
            s_lastTimeStamp = block.timestamp;
            // Emit an event to notify that a winner has been picked
            emit PickedWinner(winner); */                                                                                                                       
    
        }




    /** Getter Functions */

    function getTicketPrice() external view returns (uint256) {
        return i_ticketPrice;
    }

    function getRaffleState() external view returns (RaffleState) {
        return s_raffleState;
    }

    function getParticipant(uint256 indexofParticipant) external view returns (address) {
        return s_participants[indexofParticipant];
    }

    function getRecentWinner() external view returns (address) {
        return s_recentWinner;
    }

    function getLengthOfParticipants() external view returns (uint256) {
        return s_participants.length;
    }

    function getLastTimeStamp() external view returns (uint256) {
        return s_lastTimeStamp;
    }
                                             

}
